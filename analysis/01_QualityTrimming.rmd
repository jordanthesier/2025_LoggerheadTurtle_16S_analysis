---
title: "Quality Assessment and Trimming Loggerhead Data"
author: "Jordan"
date: "2025-03-04"
output: html_document
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, fig.align = "center", fig.path = "../figures/01_QualityTrimming")
```

# Goals of this file 

1. Use raw fastq files and generate quality plots to assess quality of reads.
2. Filter and trim out bad sequences and bases from our sequencing files. 
3. Write out fastq files with high quality sequences. 
4. Evaluate the quality from our filter and trim. 
5. Infer Errors on forward and reverse reads individually.
6. Identified ASVs on forward and reverse reads separately, using the error model.  
7. Merge forward and reverse ASVs into "contiguous ASVs".  
8. Generate the ASV count table. (`otu_table` input for phyloseq.). 

Output that we will create in this file: 

1. Quality plots to asses pre- and post-quality trimming. 
2. Written files that include the filtered and trimmed data. (Note that this will be written during the `filterAndTrim()` function.)

# Setting up the environment

### Set the seed 

Why is it useful to set a seed? 

1. *Reproducibility*:
    - If you’re using random number generation (e.g., bootstrapping, simulations, machine learning models), setting a seed ensures that you (and others) can get the same results every time you run the code.
2. *Debugging & Collaboration*:
    - If your analysis involves randomness (e.g., shuffling datasets, training ML models), setting a seed makes it easier to debug and compare results across different runs or machines.
    - Colleagues can run your code and get identical results, making scientific collaboration more reliable.
3. *Benchmarking & Model Comparisons*:
    - In machine learning, setting a seed ensures that models trained with random splits of data or initial weights are comparable across different trials.
    - If you don’t set a seed, each run might give slightly different performance metrics, making it harder to evaluate true differences between models.
4. *Avoiding Accidental Bias in Random Sampling*:
    - When selecting random subsets of data (e.g., cross-validation splits), setting a seed ensures that all experiments are based on the same random selection, reducing unwanted variability.

```{r set-seed}
set.seed(238428)
```

### Timing of Script
```{r rmd-start}
# What time did we start running this script? 
start_time <- Sys.time()
start_time
```

# Load Libraries 
```{r load-libraries}
# Efficient package loading with pacman 
# Don't forget to install pacman and DT if you don't have it yet. :)
pacman::p_load(tidyverse, dada2, phyloseq, patchwork, DT, devtools, install = FALSE)
```
# Reading Raw Sequencing Files 
```{r load-data}
# Set the raw fastq path to the raw sequencing files 
# Path to the fastq files 
raw_fastqs_path <- "./data/01_DADA2/01_raw_gzipped_fastqs"
raw_fastqs_path

# What files are in this path? Intuition Check 
head(list.files(raw_fastqs_path))

# How many files are there?
length(list.files(raw_fastqs_path))

# Create vector of forward reads
forward_reads <- list.files(raw_fastqs_path, pattern = "R1_001.fastq.gz", full.names = TRUE)

# Intuition Checks 
head(forward_reads)
# Intuition check #2: We should have fewer reads in the forward vector than in total 
stopifnot(length(forward_reads) < length(list.files(raw_fastqs_path)))

# Create a vector of reverse reads 
reverse_reads <- list.files(raw_fastqs_path, pattern = "R2_001.fastq.gz", full.names = TRUE)

# Intuition Checks
head(reverse_reads)
# Intuition check #2: Need to have equal number of forward and reverse files 
stopifnot(length(reverse_reads) == length(forward_reads))
```

# Assess Raw Read Quality 

## Evaluate raw sequence quality 

Let's see the quality of the raw reads *before* we trim
